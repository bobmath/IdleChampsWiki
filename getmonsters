#!/usr/bin/env perl
use utf8;
use strict;
use warnings;
use JSON ();

my $json = JSON->new();
#$json->boolean_values(0, 1);
$json->indent(1);
$json->canonical(1);

my $monsters = load_defines('monster_defines');
my ($attacks, $graphics) = load_other();

my @properties = qw(
   armor_based_damage
   die_after_damage_hero
   dies_at_formation
   hits_based_damage
   impassable
   indestructible
   insta_kill
   stun_immune
);

my @modifiers = qw(
   damage_modifier
   gold_modifier
   health_modifier
   speed_modifier
);

{
   my %monst_names;
   foreach my $id (sort { $a <=> $b } keys %$monsters) {
      my $monst = $monsters->{$id};
      push @{$monst_names{$monst->{name}}}, $monst;
   }

   mkdir 'monsters';
   foreach my $name (sort keys %monst_names) {
      print "$name\n";
      (my $file = $name) =~ s/\W+/_/g;
      open my $OUT, '>:utf8', "monsters/$file" or die;
      my %cats;
      print $OUT qq[<ul class="hlist">\n];

      foreach my $monst (@{$monst_names{$name}}) {
         print $OUT "<li>\n{{Monster\n";
         if (my $grname = $graphics->{$monst->{graphic_id}}) {
            my $shortname = $grname;
            $shortname =~ s/^Monster_//;
            $shortname =~ s/^.*?_(?=[[:alpha:]])//;
            print $OUT "| name = \u$shortname\n";
            print $OUT "| imgname = $grname.png\n";
         }

         show_attacks($OUT, $monst);

         if (my $tags = $monst->{tags}) {
            my $n = 0;
            foreach my $tag (sort @$tags) {
               next if $tag eq 'hits_based' || $tag eq 'armor_based';
               my $uc = ucfirst $tag;
               $n++;
               print $OUT "| tags$n = $uc\n";
               $cats{$uc} = 1;
            }
         }

         if (my $props = $monst->{properties}) {
            my %props;
            foreach my $p (@properties) {
               $props{$p} = 1 if $props->{$p};
            }
            $props{stun_immune} = 1 unless $props->{allow_stun} // 1;
            if (my $ranges = $props->{first_health_ranges}) {
               foreach my $range (@$ranges) {
                  my $type = $range->{type} or next;
                  if ($type eq 'armor_based') {
                     $props{armor_based_damage} = 1;
                  }
                  elsif ($type eq 'hits_based') {
                     $props{hits_based_damage} = 1;
                  }
               }
            }
            foreach my $p (sort keys %props) {
               print $OUT "| $p = true\n";
               my $uc = ucfirst($p);
               $uc =~ s/_/ /g;
               $cats{$uc} = 1;
            }
            show_spawn($OUT, $props);
         }

         foreach my $mod (@modifiers) {
            my $val = $monst->{$mod};
            next unless defined($val);
            print $OUT "| $mod = $val\n";
         }

         print $OUT "}}\n</li>\n";
      }

      print $OUT "</ul>\n";
      print $OUT "[[Category:$_]]\n" foreach sort keys %cats;
      close $OUT;
   }

   system 'diff -ur oldmonsters monsters' if -d 'oldmonsters';
}

sub show_spawn {
   my ($OUT, $props) = @_;
   if (my $spawn = $props->{spawns_monster_ids}) {
      my %spawn;
      foreach my $id (@$spawn) {
         my $monst = $monsters->{$id} or die;
         $spawn{$monst->{name}}++;
      }
      if (%spawn) {
      print $OUT "| spawn = ",
         join(", ", map "[[$_]]", sort keys %spawn), "\n";
      }
   }

   my $spawn = $props->{spawns_monster_on_death} or return;
   my @ids;
   if (my $id = $spawn->{monster_id}) { push @ids,  $id }
   if (my $ids = $spawn->{monster_ids}) { push @ids,  @$ids }
   my %spawn;
   foreach my $id (@ids) {
      my $monst = $monsters->{$id} or die;
      $spawn{$monst->{name}}++;
   }
   my @spawn;
   foreach my $name (sort keys %spawn) {
      my $count = $spawn{$name};
      $name = "[[$name]]";
      $name .= " Ã—$count" if $count > 1;
      push @spawn, $name;
   }
   print $OUT "| spawn_on_death = @spawn\n" if @spawn;
}

sub load_defines {
   my ($name) = @_;
   opendir my $DIR, "defines/$name" or die;
   my $data = {};
   local $/ = undef;
   foreach my $file (readdir $DIR) {
      next if $file =~ /\D/;
      open my $IN, '<:utf8', "defines/$name/$file" or die;
      $data->{$file} = $json->decode(<$IN>);
      close $IN;
   }
   closedir $DIR;
   return $data;
}

sub show_attacks {
   my ($OUT, $monst) = @_;
   my @attacks = ( $monst->{attack_id} );
   if (my $more = $monst->{properties}{more_attacks}) {
      foreach my $att (@$more) {
         push @attacks, $att->{attack_id};
      }
   }

   my $n = 0;
   my %seen;
   while (@attacks) {
      my $id = shift @attacks or next;
      next if $seen{$id};
      $seen{$id} = 1;
      my $att = $attacks->{$id} or die;
      $n++;
      print $OUT "| attack_$n = $att->{name}\n";
      foreach my $anim (@{$att->{animations}}) {
         push @attacks, $anim->{chain_attack_id},
            $anim->{update_base_attack_after};
      }
   }
}

sub load_other {
   my ($name) = @_;
   open my $IN, '<:utf8', 'define.json' or die;
   local $/ = undef;
   my $defines = $json->decode(<$IN>);
   close $IN;

   my $attacks = {};
   foreach my $att (@{$defines->{attack_defines}}) {
      $attacks->{$att->{id}} = $att;
   }

   my $graphics = {};
   foreach my $gr (@{$defines->{graphic_defines}}) {
      my $name = $gr->{graphic} or next;
      $name =~ s{^.*/}{};
      $graphics->{$gr->{id}} = $name;
   }

   return ($attacks, $graphics);
}

