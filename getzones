#!/usr/bin/env perl
use utf8;
use strict;
use warnings;
use JSON ();

my $json = JSON->new();
#$json->boolean_values(0, 1);
$json->indent(1);
$json->canonical(1);

my (%hero_names, %hero_skins, %chest_types, %graphics, %effects);
load_heroes();

my %patron_names = (
   1 => 'Mirt',
   2 => 'Vajra',
);

my %patron_coins = (
   1 => 'RubyCoins',
   2 => 'SymbolOfVajra',
);

my %navtabs = (
   1  => 'swordcoast',
   2  => 'annihilation',
   15 => 'waterdeep',
   22 => 'baldursgate',
);

my %formations = (
   1  => 'Formation Diamond Plain.png',
   2  => 'Formation Wedge Plain.png',
   15 => 'Formation Tanky Donut Plain.png',
   22 => 'Formation A-Furnace.png',
);

my %favored_enemies = (
   'armor-based' => 'Binwin, Wulfgar',
   'beast'       => 'Minsc, Zorbu',
   'drow'        => 'Zorbu',
   'fey'         => 'Minsc',
   'fiend'       => 'Turiel',
   'hit-based'   => 'Binwin',
   'humanoid'    => 'Minsc, Zorbu',
   'monstrosity' => 'Minsc',
   'undead'      => 'Minsc, Nerys, Zorbu',
);

my %event_tokens = (
   1  => "[[File:Icon_Harvest_Baskets.png|24px]] Harvest Baskets",
   2  => "[[File:Icon_Liars_Tarts.png|24px]] Liars' Tarts",
   49 => "[[File:Icon_Owlbear_Feathers.png|24px]] Owlbear Feathers",
);

my $monsters = load_defines('monster_defines');
my $campaigns = load_defines('campaign_defines');
my $favors = load_defines('reset_currency_defines');
my $backgrounds = load_defines('background_defines');
my $advents = load_defines('adventure_defines');


mkdir 'zones';
mkdir 'rawzones';
show_zones();
show_campaigns();
system 'diff', '-ur', 'oldzones', 'zones' if -d 'oldzones';

sub show_zones {
   my $sets = {};
   my $areas = load_defines('adventure_area_defines');
   foreach my $area (values %$areas) {
      $sets->{$area->{area_set_id}}{areas}{$area->{area_id}} = $area;
   }

   foreach my $adv_id (sort { $a <=> $b } keys %$advents) {
      my $advent = $advents->{$adv_id};
      next if $advent->{name} =~ /^Free Play/;
      my $set_id = $advent->{area_set_id};
      push @{$sets->{$set_id}{advents}}, $advent;
   }

   foreach my $set_id (sort { $a <=> $b } keys %$sets) {
      my $set = $sets->{$set_id};
      my $variants = $set->{advents};
      my $adv = $variants->[0] or next;
      my $camp = $campaigns->{$adv->{campaign_id}};
      push @{$camp->{_locations}{$adv->{location_id}}}, $variants;
      my $filename = make_filename($adv->{name}, $set_id);
      print $filename, "\n";
      open my $OUT, '>:utf8', "rawzones/$filename" or die;
      print $OUT $json->encode($set);
      close $OUT;
      open $OUT, '>:utf8', "zones/$filename" or die;

      print $OUT "'''$adv->{name}''' is one of the [[adventures]] ",
         "in the campaign [[$camp->{name}]].\n\n";
      show_advent($OUT, $adv);

      if (@$variants > 1) {
         print $OUT "==Variants==\n";
         foreach my $i (1 .. $#$variants) {
            my $var = $variants->[$i];
            print $OUT "===$var->{name}===\n";
            show_advent($OUT, $var);
         }
      }

      show_waves($OUT, $set->{areas});

      my $navtab = $navtabs{$adv->{campaign_id}} || 'events';
      print $OUT "{{Navbox-Adventures|show=$navtab}}\n",
         "{{Navbox-IdleChampions}}\n",
         "[[Category:Adventures]]\n",
         "[[Category:$camp->{name}]]\n";
      close $OUT;
   }
}

sub show_waves {
   my ($OUT, $areas) = @_;
   return unless $areas;
   my $top = 0;
   my (@tbl, %trash_totals, %boss_totals, @desc);
   foreach my $num (sort { $a <=> $b } keys %$areas) {
      my $area = $areas->{$num};
      my %monsters;
      add_monster_list($area->{monsters}, \%monsters);
      if (my $waves = $area->{waves}) {
         foreach my $i (0 .. $#$waves) {
            my $boss = $i >= 2 ? 1 : undef;
            add_monster_list($waves->[$i], \%monsters, $boss);
         }
      }
      if (my $props = $area->{properties}) {
         add_monster_hash($props->{static_monsters}, \%monsters);
         add_monster_gen($props->{monster_generators}, \%monsters, 0);
         if (my $help = $props->{helper_display}) {
            if (my $desc = $help->{description}) {
               $desc =~ s/\|/\n\n/g;
               push @desc, "'''Area $num''' – $desc\n\n";
            }
         }
      }

      my $zonetags = '';
      my $bkg = $backgrounds->{$area->{background_id}};
      if (ref(my $props = $bkg->{properties}) eq 'HASH') {
         if (my $tags = $props->{area_tags}) {
            $zonetags = join ' ', sort @$tags;
         }
      }

      if (my $names = $monsters{'trash-names'}) {
         my $tags = $monsters{'trash-tags'} ||= {};
         push @tbl, [ $num, $zonetags,
            join(', ', map "[[$_]]", sort keys %$names),
            show_tags($tags) ];
         $trash_totals{$_}++ foreach keys %$tags;
      }

      if (my $names = $monsters{'boss-names'}) {
         my $tags = $monsters{'boss-tags'} ||= {};
         my @names = sort keys %$names;
         foreach my $name (@names) {
            my $count = $names->{$name};
            $name = "[[$name]]";
            $name .= " ×$count" if $count > 1;
         }
         push @tbl, [ 'Boss', $zonetags, join(', ', @names),
            show_tags($tags) ];
         if (my $pics = $monsters{'boss-pics'}) {
            my $span = @tbl - $top;
            $tbl[$top][4] = "rowspan=$span align=center valign=bottom | "
               . join(' ', map "[[File:$_.png|250x150px]]", sort keys %$pics);
            $top = @tbl;
         }
         $boss_totals{$_}++ foreach keys %$tags;
      }
   }

   $trash_totals{$_} += 0 foreach keys %boss_totals;
   return unless %trash_totals;
   print $OUT qq[==Waves==\n{| class="wikitable sortable"\n],
      "|-\n! Type !! Waves !! Bosses !! Favored By\n";
   foreach my $tag (sort keys %trash_totals) {
      next if $tag eq 'boss' || $tag eq 'static';
      my $boss_count = $boss_totals{$tag} || 0;
      my $favored = $favored_enemies{$tag} || '';
      $favored = ' ' . $favored if $favored;
      print $OUT "|- align=center\n",
         "| $tag || $trash_totals{$tag} || $boss_count ||$favored\n";
   }
   print $OUT "|}\n\n";

   print $OUT qq[{| class="wikitable"\n|-\n],
      "! Wave !! Tags !! Monsters !! Monster Tags !! Image\n";
   foreach my $row (@tbl) {
      print $OUT $row->[0] eq 'Boss'
         ? qq[|- style="background-color:#333"\n] : "|-\n";
      print $OUT "| $_\n" foreach @$row;
   }
   print $OUT "|}\n\n";

   if (@desc) {
      print $OUT "===Descriptions===\n", @desc;
   }
}

sub show_tags {
   my ($tags) = @_;
   return join ' ',
      map { $favored_enemies{$_} ? "'''$_'''" : $_ }
      sort keys %$tags;
}

sub add_monster_list {
   my ($list, $monst_info, $boss) = @_;
   return unless $list;
   foreach my $id (@$list) {
      add_monster($id, $monst_info, $boss);
   }
}

sub add_monster_hash {
   my ($hash, $monst_info, $boss) = @_;
   return unless $hash;
   foreach my $key (sort keys %$hash) {
      add_monster_info($hash->{$key}, $monst_info, $boss);
   }
}

sub add_monster_gen {
   my ($generators, $monst_info, $boss) = @_;
   return unless $generators;
   foreach my $key (sort keys %$generators) {
      my $gen = $generators->{$key};
      add_monster_info($gen, $monst_info, $boss);
      add_monster_info($gen->{first_wave}, $monst_info, $boss);
      if (my $opts = $gen->{options}) {
         foreach my $opt (@$opts) {
            add_monster_info($opt, $monst_info, $boss);
         }
      }
   }
}

sub add_monster_info {
   my ($info, $monst_info, $boss) = @_;
   return unless $info;
   $boss //= $info->{boss};
   if (my $id = $info->{monster_id}) {
      add_monster($id, $monst_info, $boss);
   }
   if (my $ids = $info->{monster_ids}) {
      foreach my $id (@$ids) {
         add_monster($id, $monst_info, $boss);
      }
   }
}

sub add_monster {
   my ($id, $monst_info, $boss) = @_;
   return unless $id;
   my $monst = $monsters->{$id} or die;
   my %tags;
   $tags{$_} = 1 foreach @{$monst->{tags}};
   return if $tags{non_monster};
   my $type = $boss // $tags{boss} ? 'boss' : 'trash';
   $monst_info->{"$type-names"}{$monst->{name}}++;
   $monst_info->{"$type-pics"}{$graphics{$monst->{graphic_id}}}++;
   my $tags = $monst_info->{"$type-tags"} ||= {};
   $tags->{$_}++ foreach keys %tags;
   if (my $props = $monst->{properties}) {
      $tags->{'armor-based'}++ if $props->{armor_based_damage};
      $tags->{'hit-based'}++ if $props->{hits_based_damage};
      if (my $spawn = $props->{spawns_monster_on_death}) {
         if (my $id = $spawn->{monster_id}) {
            add_monster($id, $monst_info, $boss);
         }
         if (my $ids = $spawn->{monster_ids}) {
            foreach my $id (@$ids) {
               add_monster($id, $monst_info, $boss);
            }
         }
      } # spawn
   } # props
}

sub show_advent {
   my ($OUT, $adv) = @_;
   (my $picname = $adv->{name}) =~ s/\?/-/g;
   my $camp = $campaigns->{$adv->{campaign_id}};
   my $favor = $favors->{$camp->{reset_currency_id}};
   print $OUT "{{AdventureBox\n",
      "|icon=Icon $picname.png\n",
      "|description=$adv->{description}\n";

   my $n;
   foreach my $req (@{$adv->{requirements}}) {
      my $cond = $req->{condition};
      my $text;
      if ($cond eq 'adventure_complete') {
         my $prev = $advents->{$req->{adventure_id}} or die;
         my $name = $prev->{name};
         $name = "[[$name]]" unless $adv->{variant_adventure_id};
         $text = qq[Must have completed "$name"];
      }
      elsif ($cond eq 'adventures_completed') {
         my $prev = $campaigns->{$req->{campaign_id}} or die;
         $text = "Must have completed $req->{count} $prev->{short_name} "
            . "adventures or variants";
      }
      elsif ($cond eq 'time_gate_open') {
         my $name = $hero_names{$req->{champion_id}} or die;
         $text = "Must have an open $name Time Gate";
      }
      else {
         die $cond unless $cond eq 'not' || $cond eq 'date'
            || $cond eq 'client_version'
            || $cond eq 'event_year_unlocked';
      }
      print $OUT "|requirement", ++$n, "=$text\n" if defined $text;
   }
   if (my $costs = $adv->{costs}) {
      my @cost;
      foreach my $cost (@$costs) {
         die unless $cost->{cost} eq 'event_tokens';
         my $name = $event_tokens{$cost->{event_id}} or die;
         push @cost, "$cost->{amount} $name";
      }
      if (@cost) {
         my $text = "Costs @cost to start";
         print $OUT "|requirement", ++$n, "=$text\n";
      }
   }

   print $OUT "|objectives=$adv->{objectives_text}\n";

   my $restr = $adv->{restrictions_text};
   $restr =~ s/\s*\n/<br>/g;
   print $OUT "|restrictions=$restr\n" unless lc($restr) eq 'no restrictions';

   my @rewards = get_rewards($adv->{rewards}, $adv->{name});
   if ($favor) {
      (my $name = $favor->{name}) =~ s/'.*//;
      push @rewards, "{{DivineFavor|$name|size=32px|×???}}";
   }
   print $OUT "|rewards=@rewards\n" if @rewards;

   my $form = get_formation($adv) || "Formation $picname.png";
   print $OUT "|formation=$form\n";

   my $patrons = $adv->{patron_objectives};
   $patrons = {} unless ref($patrons) eq 'HASH';
   $n = 0;
   foreach my $patid (sort keys %$patrons) {
      my $patvar = $patrons->{$patid};
      my $name = $patron_names{$patid} || 'Unknown';

      foreach my $varid (sort keys %$patvar) {
         my @obj;
         foreach my $obj (@{$patvar->{$varid}}) {
            my $cond = $obj->{condition};
            if ($cond eq 'complete_area') {
               push @obj, "Complete Area $obj->{area}";
            }
            elsif ($cond eq 'objective_time_limit') {
               my $mins = $obj->{time} / 60;
               push @obj, "Within $mins Minutes";
            }
            else {
               warn "$adv->{name} $cond";
            }
         }
         my @rewards = get_rewards($adv->{patron_rewards}{$patid}{$varid},
            $adv->{name});

         $n++;
         print $OUT "|patronname$n=$name\n";
         print $OUT "|patronobjectives$n=@obj\n" if @obj;
         print $OUT "|patronrewards$n=@rewards\n" if @rewards;
      }
   }

   print $OUT "}}\n\n";
}

sub get_formation {
   my ($adv) = @_;
   if (my $changes = $adv->{game_changes}) {
      foreach my $change (@$changes) {
         my $type = $change->{type};
         return if $type eq 'formation'
            || $type eq 'slot_escort'
            || $type eq 'slot_escort_by_area'
            || $type eq 'force_use_heroes';
         return if $type eq 'only_allow_crusaders'
            && $change->{by_tags}{target_slots};
      }
   }
   return $formations{$adv->{campaign_id}};
}

sub get_rewards {
   my ($rewards, $where) = @_;
   my @rewards;
   foreach my $reward (@$rewards) {
      my $type = $reward->{reward};
      if ($type eq 'red_rubies') {
         my $num = commify($reward->{amount});
         push @rewards, "{{Gems|size=32px|×$num}}";
      }
      elsif ($type eq 'patron_currency') {
         my $what = $patron_coins{$reward->{patron_id}} || 'UnknownCoin';
         my $num = commify($reward->{amount});
         push @rewards, "{{$what|×$num}}";
      }
      elsif ($type eq 'patron_influence') {
         my $who = $patron_names{$reward->{patron_id}} || 'Unknown';
         my $amt = sci($reward->{amount});
         push @rewards, "{{${who}Influence|×$amt}}";
      }
      elsif ($type eq 'claim_crusader') {
         my $who = $hero_names{$reward->{crusader_id}} || 'Unknown';
         push @rewards, "{{Icon-Link|size=32px|$who}}";
      }
      elsif ($type eq 'chest') {
         my $chest = $chest_types{$reward->{chest_type_id}} || 'Unknown Chest';
         push @rewards, $chest;
      }
      elsif ($type eq 'champion_skin') {
         my $skin = $hero_skins{$reward->{skin_id}} || 'Unknown';
         push @rewards, "[[File:Icon $skin.png|32px]] $skin";
      }
      else {
         warn "Unknown reward in $where: $type";
      }
   }
   return @rewards;
}

sub show_campaigns {
   my $tiers = load_defines('reset_tier_defines');
   foreach my $tier (values %$tiers) {
      $favors->{$tier->{reset_currency_id}}{_tiers}{$tier->{tier_id}} = $tier;
   }

   my $upgrades = load_defines('reset_upgrade_defines');
   foreach my $id (sort { $a <=> $b } keys %$upgrades) {
      my $upg = $upgrades->{$id};
      my $tier = $favors->{$upg->{reset_currency_id}}{_tiers}{$upg->{tier_id}}
         or die;
      push @{$tier->{_upgrades}}, $upg;
      my @desc;
      foreach my $eff (@{$upg->{effects}}) {
         my @eff = split /,/, $eff->{effect_string};
         my $desc = $eff->{override_desc}
            || $effects{$eff[0] eq 'effect_def' ? $eff[1] : $eff[0]}
            or next;
         $eff->{_eff} = \@eff;
         $desc =~ s{\$(\w+|\(.*?\))}{
            my $str = $1;
            get_effect_val($str, $eff) // '$' . $str;
         }eg;
         push @desc, $desc;
      }
      $upg->{_desc} = join ' and ', @desc;
      my $props = $upg->{properties};
      $props = {} unless ref($props) eq 'HASH';
      $upg->{_desc} .= ' over all Campaigns' if $upg->{type} == 2
         && !$props->{remove_global_text};
   }

   my $locations = load_defines('location_defines');
   for my $camp_id (sort { $a <=> $b } keys %$campaigns) {
      my $camp = $campaigns->{$camp_id} or next;
      my $locs = $camp->{_locations} or next;
      my $filename = make_filename($camp->{name}, $camp_id);
      open my $OUT, '>:utf8', "zones/$filename" or die;
      print $OUT "==Adventures==\n";
      foreach my $loc_id (sort { $a <=> $b } keys %$locs) {
         my $loc = $locations->{$loc_id} or next;
         print $OUT "*$loc->{name}\n";
         foreach my $zone (@{$locs->{$loc_id}}) {
            my @names = map "[[$_->{name}]]", @$zone;
            my $line = shift @names;
            $line .= ' – ' . join(', ', @names) if @names;
            print $OUT "**$line\n";
         }
      }
      print $OUT "\n";
      show_blessings($OUT, $favors->{$camp->{reset_currency_id}});
      close $OUT;
   }
}

sub show_blessings {
   my ($OUT, $favor) = @_;
   return unless $favor;
   my $tiers = $favor->{_tiers} or return;
   (my $name = $favor->{name}) =~ s/'s.*//;
   print $OUT "==Blessings==\n",
      "Adventures in this campaign grant {{DivineFavor|$name|$favor->{name}}}",
      ", which can be used to purchase the following blessings.\n",
      qq[{| class="wikitable"\n|-\n],
      "! Name !! Description !! Base&nbsp;Cost !! Levels !! Total&nbsp;Cost\n";
   for my $tid (sort { $a <=> $b } keys %$tiers) {
      my $tier = $tiers->{$tid};
      my $desc = "Tier $tid";
      foreach my $req (@{$tier->{requirements}}) {
         my $type = $req->{type};
         if ($type eq 'reset_upgrades_purchased') {
            $desc .= " – Requires $req->{amount} Blessings";
         }
         else {
            $desc .= ' – ???';
         }
      }
      print $OUT "|-\n| colspan=5 | $desc\n";

      foreach my $upg (@{$tier->{_upgrades}}) {
         my $base = $upg->{cost}{base_cost};
         my $mult = $upg->{cost}{scaling};
         my $num = $upg->{levels};
         my $total = $mult == 1 ? $base * $num
            : $base * ($mult ** $num - 1) / ($mult - 1);
         $base = sci($base);
         $total = sci($total);
         print $OUT "|-\n| '''$upg->{name}'''\n| $upg->{_desc}\n",
            "| $base || $num || $total\n";
      }
   }
   print $OUT "|}\n\n";
}

sub get_effect_val {
   my ($str, $eff) = @_;
   $str = $1 if $str =~ /^\((.*)\)$/;
   if ($str eq 'amount') {
      return $eff->{per_level} if $eff->{per_level};
      return if $eff->{_eff}[0] eq 'effect_def';
      return $eff->{_eff}[1];
   }
   elsif ($str eq 'as_multiplier amount') {
      return $eff->{per_level} / 100 + 1;
   }
   elsif ($str eq 'describe_rarity rarity') {
      return 'Epic';
   }
   elsif ($str eq 'describe_tags tag') {
      return $eff->{_eff}[2];
   }
   elsif ($str eq 'describe_tags tag_expression') {
      return $eff->{_eff}[2];
   }
   elsif ($str eq 'reset_currency_name optional_currency') {
      my $favor = $favors->{$eff->{_eff}[2]} or return;
      return $favor->{name};
   }
   elsif ($str eq 'seconds_comparison_description') {
      my $op = $eff->{_eff}[2] or return;
      my $val = $eff->{_eff}[3] or return;
      return "greater than $val seconds" if $op eq '>';
      return "$val seconds or lower" if $op eq '<=';
   }
   elsif ($str eq 'seconds_plural amount') {
      my $sec = $eff->{per_level} or return;
      return "$sec seconds";
   }
   elsif ($str eq 'target') {
      return $eff->{target_name} || 'all Champions';
   }
   return;
}

sub load_defines {
   my ($name) = @_;
   opendir my $DIR, "defines/$name" or die;
   my $data = {};
   local $/ = undef;
   foreach my $file (readdir $DIR) {
      next if $file =~ /\D/;
      open my $IN, '<:utf8', "defines/$name/$file" or die;
      $data->{$file} = $json->decode(<$IN>);
      close $IN;
   }
   closedir $DIR;
   return $data;
}

sub load_heroes {
   open my $IN, '<:utf8', 'define.json' or die;
   local $/ = undef;
   my $data = $json->decode(<$IN>);
   close $IN;
   build_name_index($data->{hero_defines}, \%hero_names);
   build_name_index($data->{hero_skin_defines}, \%hero_skins);
   build_name_index($data->{chest_type_defines}, \%chest_types);

   if (my $defines = $data->{graphic_defines}) {
      foreach my $graphic (@$defines) {
         my $name = $graphic->{graphic} or next;
         $name =~ s{^.*/}{};
         $graphics{$graphic->{id}} = $name;
      }
   }

   foreach my $eff (@{$data->{effect_key_defines}}) {
      my $desc = $eff->{descriptions};
      next unless ref($desc) eq 'HASH';
      $effects{$eff->{key}} = $desc->{desc};
   }

   foreach my $eff (@{$data->{effect_defines}}) {
      $effects{$eff->{id}} = $eff->{description};
   }
}

sub build_name_index {
   my ($defines, $index) = @_;
   return unless $defines;
   foreach my $rec (@$defines) {
      $index->{$rec->{id}} = $rec->{name};
   }
}

my %seen_files;
sub make_filename {
   my ($file, $id) = @_;
   $file =~ s{[\s:/\\]+}{_}g;
   $file =~ s/^\./_./;
   $file .= '-' . ($id||'') if $seen_files{$file};
   if ($seen_files{$file}) {
      $file .= ++$seen_files{$file};
   }
   else {
      $seen_files{$file} = 'a';
   }
   return $file;
}

sub sci {
   my ($x) = @_;
   return sprintf('%.3g', $x) if abs($x) < 999.5;
   $x = sprintf('%.2e', $x);
   $x =~ s/e\+?0*/e/;
   return $x
}

sub commify {
   my ($x) = @_;
   my ($num, $tail) = $x =~ /^(\d+)(.*)/ or return $x;
   my @parts;
   my $pos = length($num);
   while ($pos > 3) {
      $pos -= 3;
      push @parts, substr($num, $pos, 3);
   }
   push @parts, substr($num, 0, $pos);
   return join(',', reverse @parts) . $tail;
}

